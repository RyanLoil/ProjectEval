{
  "16": [
    {
      "file": "16-stdanswer.py",
      "path": "16-stdanswer.py",
      "code": "import os\nimport pandas as pd\n\n# File paths\ninput_file = \"Spring Semester Subjects.xlsx\"\noutput_file = \"Processed Subjects Table.xlsx\"\n\n# Function to check if the file exists\ndef check_file_exists(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"Error: The file '{file_path}' does not exist.\")\n\n# Function to check if the file is in the correct format (Excel)\ndef check_file_format(file_path):\n    if not file_path.lower().endswith(('.xls', '.xlsx')):\n        raise ValueError(f\"Error: The file '{file_path}' is not an Excel file. Please provide a valid Excel file.\")\n\n# Function to validate the data (headers and data completeness)\ndef validate_data(df):\n    # Check if all required columns are present\n    required_columns = [\"#\", \"Name\", \"Weekday\", \"Time\"]\n    if not all(column in df.columns for column in required_columns):\n        raise ValueError(f\"Error: The input file is missing one or more required columns: {required_columns}\")\n    \n    # Check if there are any missing values in the required columns\n    if df[required_columns].isnull().any().any():\n        raise ValueError(\"Error: There are missing values in the input data. Please fill in all required fields.\")\n    \n    # Check for invalid 'Time' values\n    valid_times = [\"First period\", \"Second period\", \"Third period\", \"Fourth period\"]\n    invalid_times = df[~df['Time'].isin(valid_times)]\n    if not invalid_times.empty:\n        raise ValueError(f\"Error: Invalid time values found: {invalid_times['Time'].unique()}. Valid options are {valid_times}.\")\n\n    # Check for invalid weekdays\n    valid_weekdays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n    invalid_weekdays = df[~df['Weekday'].isin(valid_weekdays)]\n    if not invalid_weekdays.empty:\n        raise ValueError(f\"Error: Invalid weekday values found: {invalid_weekdays['Weekday'].unique()}. Valid options are {valid_weekdays}.\")\n\n# Main program to process the file\ndef process_subjects(input_file, output_file):\n    try:\n        # Check if the file exists and is in the correct format\n        check_file_exists(input_file)\n        check_file_format(input_file)\n\n        # Read the Excel file\n        df = pd.read_excel(input_file)\n\n        # Validate the data\n        validate_data(df)\n\n        # Define the periods and weekdays\n        periods = [\"First period\", \"Second period\", \"Third period\", \"Fourth period\"]\n        weekdays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n\n        # Create an empty dataframe for the two-dimensional subject table\n        table = pd.DataFrame(index=weekdays, columns=periods)\n\n        # Populate the table with subject names\n        for _, row in df.iterrows():\n            weekday = row[\"Weekday\"]\n            time = row[\"Time\"]\n            name = row[\"Name\"]\n            table.at[weekday, time] = name\n\n        # Save the output to a new Excel file\n        table.to_excel(output_file)\n\n        print(f\"Processed subject table saved to {output_file}\")\n    \n    except (FileNotFoundError, ValueError) as e:\n        print(str(e))\n\n# Run the process\nprocess_subjects(input_file, output_file)\n"
    }
  ],
  "17": [
    {
      "file": "17-stdanswer.py",
      "path": "17-stdanswer.py",
      "code": "import pandas as pd\nimport statsmodels.api as sm\nimport os\n\n# File paths\ninput_file = \"Gamedata.xlsx\"\noutput_file = \"Logistic.xlsx\"\n\ndef read_and_validate_data(input_file):\n    \"\"\"\n    Reads the dataset and ensures all columns are numeric. \n    If any missing values (NaN) are found, raises an error.\n    \"\"\"\n    # Read the dataset\n    if not os.path.exists(input_file):\n        raise FileNotFoundError(f\"Error: The file '{input_file}' does not exist.\")\n    data = pd.read_excel(input_file)\n\n    # Convert all columns to numeric, coercing invalid values to NaN\n    data = data.apply(pd.to_numeric, errors='coerce')\n\n    # Check for missing values (NaN)\n    if data.isnull().any().any():\n        raise ValueError(\"Dataset contains missing or invalid values. Please clean the data and try again.\")\n\n    return data\n\ndef add_lagged_dependent_variable(data, target_column):\n    \"\"\"\n    Adds a one-period lag for the dependent variable and drops missing rows.\n    \"\"\"\n    data['lagged_result'] = data[target_column].shift(1)\n    data = data.dropna()  # Drop rows with NaN introduced by lagging\n    return data\n\ndef prepare_features_and_target(data, target_column, lagged_column):\n    \"\"\"\n    Prepares the feature matrix (X) and target vector (y).\n    \"\"\"\n    independent_vars = [col for col in data.columns if col not in [target_column, lagged_column]]\n    X = sm.add_constant(data[independent_vars])  # Add intercept term\n    y = data[lagged_column]\n    return X, y\n\ndef build_logistic_model(X, y):\n    \"\"\"\n    Builds and fits a logistic regression model.\n    \"\"\"\n    model = sm.Logit(y, X)\n    result = model.fit()\n    return result\n\ndef save_summary_to_excel(result, output_file):\n    \"\"\"\n    Saves the logistic regression summary to an Excel file.\n    \"\"\"\n    summary_text = result.summary().as_text()\n    summary_lines = [line.split() for line in summary_text.split('\\n') if line.strip()]\n\n    # Convert to DataFrame for saving to Excel\n    summary_df = pd.DataFrame(summary_lines)\n    with pd.ExcelWriter(output_file, engine='openpyxl') as writer:\n        summary_df.to_excel(writer, index=False, header=False, sheet_name=\"Logistic Model Summary\")\n\ndef main(input_file, output_file):\n    \"\"\"\n    Main function to execute all steps.\n    \"\"\"\n    data = read_and_validate_data(input_file)\n    data = add_lagged_dependent_variable(data, target_column='result')\n    X, y = prepare_features_and_target(data, target_column='result', lagged_column='lagged_result')\n    if X.empty or y.empty:\n        raise ValueError(\"Feature matrix or target vector is empty. Check your input data.\")\n\n    result = build_logistic_model(X, y)\n    save_summary_to_excel(result, output_file)\n    print(f\"Logistic regression summary saved to {output_file}.\")\n\n# Run the program\nif __name__ == \"__main__\":\n    main(input_file, output_file)\n"
    }
  ],
  "18": [
    {
      "file": "18-stdanswer.py",
      "path": "18-stdanswer.py",
      "code": "import os\nimport textwrap\n\n\nclass BashCrawl:\n    def __init__(self):\n        self.current_dir = os.path.sep  # Use os.path.sep for platform-specific root directory\n        self.directory_structure = {\n            os.path.sep: [\"home\", \"forest\", \"cave\"],\n            os.path.join(os.path.sep, \"home\"): [\"kitchen\", \"bedroom\"],\n            os.path.join(os.path.sep, \"forest\"): [\"clearing\", \"deep_forest\"],\n            os.path.join(os.path.sep, \"cave\"): [\"treasure_room\"],\n            os.path.join(os.path.sep, \"home\", \"kitchen\"): [],\n            os.path.join(os.path.sep, \"home\", \"bedroom\"): [],\n            os.path.join(os.path.sep, \"forest\", \"clearing\"): [],\n            os.path.join(os.path.sep, \"forest\", \"deep_forest\"): [],\n            os.path.join(os.path.sep, \"cave\", \"treasure_room\"): [],\n        }\n        self.items = {os.path.join(os.path.sep, \"cave\", \"treasure_room\"): \"golden_key\"}\n        self.inventory = []\n        self.commands = [\"ls\", \"cd\", \"inventory\", \"help\", \"quit\"]\n\n    def print_main_menu(self):\n        print(\"\\n=== BashCrawl Main Menu ===\")\n        print(\"1. Start Game\")\n        print(\"2. Help\")\n        print(\"3. Quit\")\n\n    def main_menu_help(self):\n        print(textwrap.dedent(f\"\"\"\n            Welcome to the BashCrawl Main Menu!\n            Here are your options:\n            1. Start Game - Begin your adventure.\n            2. Help - Learn how to play the game.\n            3. Quit - Exit the program.\n        \"\"\"))\n\n    def print_game_help(self):\n        print(textwrap.dedent(\"\"\"\n            In-game commands:\n            - ls: List the contents of the current directory.\n            - cd <dir>: Move into a directory.\n            - inventory: Check what you're carrying.\n            - help: Show this help message.\n            - quit: Exit the game.\n\n            Your goal is to find the golden key hidden in the cave and return to the root directory.\n        \"\"\"))\n\n    def list_contents(self):\n        contents = self.directory_structure.get(self.current_dir, [])\n        if contents:\n            print(\"\\n\".join(contents))\n        else:\n            print(\"This directory is empty.\")\n\n    def change_directory(self, target_dir):\n        new_dir = os.path.normpath(os.path.join(self.current_dir, target_dir))\n        if new_dir in self.directory_structure:\n            self.current_dir = new_dir\n            print(f\"You are now in {self.current_dir}\")\n            # Check for items\n            if new_dir in self.items:\n                item = self.items.pop(new_dir)\n                self.inventory.append(item)\n                print(f\"You found a {item}!\")\n        else:\n            print(\"No such directory!\")\n\n    def check_inventory(self):\n        if self.inventory:\n            print(\"You are carrying:\")\n            print(\"\\n\".join(self.inventory))\n        else:\n            print(\"Your inventory is empty.\")\n\n    def play(self):\n        print(\"Welcome to BashCrawl!\")\n        print(\"Your goal is to find the golden key and escape the cave.\")\n        self.print_game_help()\n\n        while True:\n            print(f\"\\nCurrent location: {self.current_dir}\")\n            command = input(\"$ \").strip().split()\n\n            if not command:\n                continue\n\n            action = command[0]\n            if action not in self.commands:\n                print(\"Unknown command. Type 'help' for a list of commands.\")\n                continue\n\n            if action == \"ls\":\n                self.list_contents()\n            elif action == \"cd\":\n                if len(command) > 1:\n                    self.change_directory(command[1])\n                else:\n                    print(\"Usage: cd <dir>\")\n            elif action == \"inventory\":\n                self.check_inventory()\n            elif action == \"help\":\n                self.print_game_help()\n            elif action == \"quit\":\n                print(\"Thanks for playing BashCrawl. Goodbye!\")\n                break\n\n            # Check win condition\n            if \"golden_key\" in self.inventory and self.current_dir == os.path.sep:\n                print(\"Congratulations! You've found the golden key and escaped!\")\n                break\n\n    def main_menu(self):\n        self.print_main_menu()\n        while True:\n            choice = input(\"Choose an option (1, 2, or 3): \").strip()\n            if choice == \"1\":\n                self.play()\n                self.print_main_menu()\n            elif choice == \"2\":\n                self.main_menu_help()\n            elif choice == \"3\":\n                print(\"Goodbye!\")\n                break\n            else:\n                print(\"Invalid option. Please choose 1, 2, or 3.\")\n\n\nif __name__ == \"__main__\":\n    game = BashCrawl()\n    game.main_menu()\n"
    }
  ],
  "19": [
    {
      "file": "19-stdanswer.py",
      "path": "19-stdanswer.py",
      "code": "import pandas as pd\nimport matplotlib.pyplot as plt\nimport os\n\ndef check_file_existence(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"The file '{file_path}' does not exist.\")\n\ndef read_dataset(file_path):\n    try:\n        check_file_existence(file_path)\n        df = pd.read_csv(file_path)\n        if df.empty:\n            raise ValueError(\"The dataset is empty.\")\n        return df\n    except FileNotFoundError:\n        raise FileNotFoundError(f\"The file '{file_path}' was not found.\")\n\ndef validate_dataset(df, required_columns):\n    missing_columns = [col for col in required_columns if col not in df.columns]\n    if missing_columns:\n        raise KeyError(f\"The dataset is missing the following required columns: {', '.join(missing_columns)}\")\n    return df\n\ndef preprocess_dataset(df):\n    non_date_entries = df[~df['Date of death'].astype(str).str.match(r'^\\\\d{4}-\\\\d{2}-\\\\d{2}$', na=False)]\n    if not non_date_entries.empty:\n        print(f\"Warning: Found {len(non_date_entries)} non-date entries. These will be ignored.\")\n    df['Date of death'] = pd.to_datetime(df['Date of death'], errors='coerce')\n    invalid_dates = df['Date of death'].isna().sum()\n    if invalid_dates > 0:\n        print(f\"Warning: {invalid_dates} invalid date entries were found and will be ignored.\")\n    df = df.dropna(subset=['Date of death'])\n    if df.empty:\n        raise ValueError(\"The dataset contains no valid 'Date of death' entries after cleaning.\")\n    df['Week'] = df['Date of death'].dt.to_period('W')\n    return df\n\ndef plot_weekly_deaths(weekly_deaths, output_file):\n    plt.figure(figsize=(12, 6))\n    weekly_deaths.plot(kind='bar', color='skyblue', edgecolor='black')\n    plt.title('Weekly Deaths', fontsize=16)\n    plt.xlabel('Week', fontsize=14)\n    plt.ylabel('Number of Deaths', fontsize=14)\n    plt.xticks(rotation=45, fontsize=10)\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()\n\ndef main():\n    try:\n        file_path = 'Deathlist.csv'\n        output_file = 'weekly_deaths_histogram.png'\n        required_columns = ['Date of death']\n\n        df = read_dataset(file_path)\n        validate_dataset(df, required_columns)\n        df = preprocess_dataset(df)\n        \n        weekly_deaths = df.groupby('Week').size()\n        plot_weekly_deaths(weekly_deaths, output_file)\n        print(f\"Histogram saved as '{output_file}'.\")\n\n    except (FileNotFoundError, KeyError, ValueError) as e:\n        print(e)\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\nif __name__ == '__main__':\n    main()\n"
    }
  ]
}